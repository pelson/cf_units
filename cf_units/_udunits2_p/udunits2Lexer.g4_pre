lexer grammar udunits2Lexer;

SIGNED_INT : (MINUS|PLUS) INT ;
fragment ANY_INT: INT | SIGNED_INT ;

PLUS: '+' ;
MINUS: '-' ;
MULTIPLY: ('*' | '·') ;
DIVIDE: '/' ;
PERIOD: '.' ;

OPEN_PAREN: '(' ;
CLOSE_PAREN: ')' ;
SEMICOLON: ':' ;

INT : '0'..'9'+ ;

E_POWER: ('E' | 'e') ANY_INT ;
// NOTE: floats themselves are context sensitive, see the parser rules (especially float_t).



SHIFT_OP:
  ( '@'
  | 'after'
  | 'from'
  | 'since'
  | 'ref'
  )  -> pushMode(SHIFT_MODE)
;


UNICODE_EXPONENT:
  // One or more ISO-8859-9 encoded exponent characters
  ('⁻' | '⁺' | '¹' | '²' | '³' | '⁴' | '⁵' | '⁶' | '⁷' | '⁸' | '⁹' | '⁰')+
; 

RAISE :
  ( '^'
  | '**'
  )
;

//ID: one of
//        <id>
//        '%'
//        "'"
//        "\""
//        degree sign
//        greek mu character
//
ID:  [A-Za-z_]+ ;

WS : [ ] ;

// Any characters which fail to match will raise an error.
// nb. without this token, we don't get quite as good error messages. TODO: test for this!
ERRORCHARACTER : . ;



mode SHIFT_MODE;
// This mode is only enabled after seeing a SHIFT_OP token.

fragment SIGN:
    PLUS | MINUS
;

fragment HOUR:
    // NOTE: -19 is fine, -20 is not in the current udunits implementation.
    (SIGN? ('0'..'1')? ('0'..'9')) | (('2' ('0'..'3')))
;

fragment MINUTE:
    ('0'..'5')? ('0'..'9')
;

fragment SECOND:
    (MINUTE | '60') (PERIOD ('0'..'9')*)?
;

fragment MONTH:
    ('0'? ('1'..'9')) | ('1' ('0'..'2'))
;

fragment DAY:
    ('0'? ('1'..'9')) | (('1'..'2')('0'..'9')) | '30' | '31'
;

fragment YEAR:
    SIGN? INT INT? INT? INT?
;

HOUR_MINUTE_SECOND: HOUR ':' MINUTE ':' SECOND;
HOUR_MINUTE: HOUR ':' MINUTE;

DATE: (YEAR MINUS MONTH (MINUS DAY)?);

fragment CLOCK: HOUR (MINUTE SECOND?)?;

TIMESTAMP: 
    (YEAR (MONTH DAY?)? 'T' CLOCK)
;

DT_T_CLOCK: DATE 'T' CLOCK; // UNDOCUMENTED

// inherit from DEFAULT_MODE: INT, SIGNED_INT, E_POWER, WS, PLUS, MINUS, PERIOD, SEMICOLON, ERRORCHARACTER;
