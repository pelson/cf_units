lexer grammar udunits2Lexer;

SIGNED_INT : (MINUS|PLUS) '0'..'9'+ ;
fragment ANY_INT: INT | SIGNED_INT;

PLUS: '+';
MINUS: '-';
MULTIPLY: ('*' | '·');
DIVIDE: '/';
PERIOD: '.';

OPEN_PAREN: '(';
CLOSE_PAREN: ')';
SEMICOLON: ':';

fragment INTEGER
   : ('0' .. '9')+
   ;

INT : '0'..'9'+ ;


E_POWER:
     ('E' | 'e') ANY_INT 
;



fragment MONTH:
    ('0'? ('1'..'9')) | ('1' ('0'..'2'))
;

fragment DAY:
    ('0'? ('1'..'9')) | (('1'..'2')('0'..'9')) | '30' | '31'
;

SHIFT_OP :
         ('@'
         | 'after'
         | 'from'
         | 'since'
         | 'ref')  -> pushMode(SHIFT_MODE) ;

WS : [ ] ;

UNICODE_EXPONENT:
    // One or more ISO-8859-9 encoded exponent characters
    ('⁻' | '⁺' | '¹' | '²' | '³' | '⁴' | '⁵' | '⁶' | '⁷' | '⁸' | '⁹' | '⁰')+
; 

RAISE :
         '^'
       | '**'
;

//ID: one of
//        <id>
//        '%'
//        "'"
//        "\""
//        degree sign
//        greek mu character
//
ID:  [A-Za-z_]+ ;

// Any characters which fail to match will raise an error.
// nb. without this token, we don't get quite as good error messages. TODO: test for this!
ERRORCHARACTER : . ;



mode SHIFT_MODE;

fragment SIGN:
    PLUS | MINUS
;

fragment HOUR:
    // NOTE: -19 is fine, -20 is not in the current udunits implementation.
    (SIGN? ('0'..'1')? ('0'..'9')) | (('2' ('0'..'3')))
;

fragment MINUTE:
    ('0'..'5')? ('0'..'9')
;

fragment SECOND:
    (MINUTE | '60') (PERIOD ('0'..'9')*)?
;

HOUR_MINUTE_SECOND: HOUR ':' MINUTE ':' SECOND;
HOUR_MINUTE: HOUR ':' MINUTE;

DATE: (ANY_INT MINUS MONTH (MINUS DAY)?);

fragment CLOCK: HOUR (MINUTE SECOND?)?;

TIMESTAMP: 
    (ANY_INT (MONTH DAY?)? 'T' CLOCK)
;

DT_T_CLOCK: DATE 'T' CLOCK; // UNDOCUMENTED



// inherit from DEFAULT_MODE: INT, SIGNED_INT, E_POWER, WS, PLUS, MINUS, PERIOD, SEMICOLON, HOUR_MINUTE, HOUR_MINUTE_SECOND, ERRORCHARACTER;

