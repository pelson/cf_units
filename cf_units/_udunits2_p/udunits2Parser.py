# Generated from udunits2Parser.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\31")
        buf.write("\u00b1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\3\2\5\2(\n\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\5\3\65\n\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\3\4\6\4D\n\4\r\4\16\4E\3\4\7\4I\n\4\f\4\16")
        buf.write("\4L\13\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5")
        buf.write("\5Y\n\5\3\6\3\6\3\6\3\6\3\6\3\6\5\6a\n\6\3\7\3\7\3\b\3")
        buf.write("\b\5\bg\n\b\3\t\3\t\3\n\3\n\3\13\3\13\3\f\5\fp\n\f\3\f")
        buf.write("\3\f\3\r\3\r\5\rv\n\r\3\16\3\16\3\17\5\17{\n\17\3\17\3")
        buf.write("\17\3\17\5\17\u0080\n\17\3\17\3\17\5\17\u0084\n\17\3\17")
        buf.write("\5\17\u0087\n\17\3\17\3\17\5\17\u008b\n\17\3\17\5\17\u008e")
        buf.write("\n\17\3\20\3\20\3\20\5\20\u0093\n\20\3\21\5\21\u0096\n")
        buf.write("\21\3\21\3\21\7\21\u009a\n\21\f\21\16\21\u009d\13\21\3")
        buf.write("\21\5\21\u00a0\n\21\3\22\3\22\3\23\7\23\u00a5\n\23\f\23")
        buf.write("\16\23\u00a8\13\23\3\23\3\23\7\23\u00ac\n\23\f\23\16\23")
        buf.write("\u00af\13\23\3\23\2\3\6\24\2\4\6\b\n\f\16\20\22\24\26")
        buf.write("\30\32\34\36 \"$\2\6\4\2\3\3\13\13\4\2\13\13\27\27\4\2")
        buf.write("\13\13\26\26\3\2\25\26\2\u00bd\2\'\3\2\2\2\4\64\3\2\2")
        buf.write("\2\6\66\3\2\2\2\bX\3\2\2\2\n`\3\2\2\2\fb\3\2\2\2\16f\3")
        buf.write("\2\2\2\20h\3\2\2\2\22j\3\2\2\2\24l\3\2\2\2\26o\3\2\2\2")
        buf.write("\30u\3\2\2\2\32w\3\2\2\2\34\u008d\3\2\2\2\36\u0092\3\2")
        buf.write("\2\2 \u009f\3\2\2\2\"\u00a1\3\2\2\2$\u00a6\3\2\2\2&(\5")
        buf.write("\4\3\2\'&\3\2\2\2\'(\3\2\2\2()\3\2\2\2)*\7\2\2\3*\3\3")
        buf.write("\2\2\2+\65\5\6\4\2,-\5\6\4\2-.\5$\23\2./\5\16\b\2/\65")
        buf.write("\3\2\2\2\60\61\5\6\4\2\61\62\5$\23\2\62\63\5\34\17\2\63")
        buf.write("\65\3\2\2\2\64+\3\2\2\2\64,\3\2\2\2\64\60\3\2\2\2\65\5")
        buf.write("\3\2\2\2\66\67\b\4\1\2\678\5\b\5\28J\3\2\2\29:\f\6\2\2")
        buf.write(":I\5\b\5\2;<\f\5\2\2<=\7\5\2\2=I\5\b\5\2>?\f\4\2\2?@\7")
        buf.write("\6\2\2@I\5\b\5\2AC\f\3\2\2BD\7\23\2\2CB\3\2\2\2DE\3\2")
        buf.write("\2\2EC\3\2\2\2EF\3\2\2\2FG\3\2\2\2GI\5\b\5\2H9\3\2\2\2")
        buf.write("H;\3\2\2\2H>\3\2\2\2HA\3\2\2\2IL\3\2\2\2JH\3\2\2\2JK\3")
        buf.write("\2\2\2K\7\3\2\2\2LJ\3\2\2\2MN\5\n\6\2NO\5\22\n\2OY\3\2")
        buf.write("\2\2PY\5\n\6\2QR\5\n\6\2RS\7\20\2\2ST\5\22\n\2TY\3\2\2")
        buf.write("\2UV\5\n\6\2VW\7\17\2\2WY\3\2\2\2XM\3\2\2\2XP\3\2\2\2")
        buf.write("XQ\3\2\2\2XU\3\2\2\2Y\t\3\2\2\2Za\7\21\2\2[\\\7\b\2\2")
        buf.write("\\]\5\4\3\2]^\7\t\2\2^a\3\2\2\2_a\5\16\b\2`Z\3\2\2\2`")
        buf.write("[\3\2\2\2`_\3\2\2\2a\13\3\2\2\2bc\t\2\2\2c\r\3\2\2\2d")
        buf.write("g\5\f\7\2eg\7\r\2\2fd\3\2\2\2fe\3\2\2\2g\17\3\2\2\2hi")
        buf.write("\t\2\2\2i\21\3\2\2\2jk\t\2\2\2k\23\3\2\2\2lm\7\4\2\2m")
        buf.write("\25\3\2\2\2np\5\24\13\2on\3\2\2\2op\3\2\2\2pq\3\2\2\2")
        buf.write("qr\5\30\r\2r\27\3\2\2\2sv\5\32\16\2tv\5\22\n\2us\3\2\2")
        buf.write("\2ut\3\2\2\2v\31\3\2\2\2wx\7\r\2\2x\33\3\2\2\2y{\7\23")
        buf.write("\2\2zy\3\2\2\2z{\3\2\2\2{|\3\2\2\2|\u008e\t\3\2\2}\177")
        buf.write("\t\3\2\2~\u0080\7\23\2\2\177~\3\2\2\2\177\u0080\3\2\2")
        buf.write("\2\u0080\u0081\3\2\2\2\u0081\u0086\5\36\20\2\u0082\u0084")
        buf.write("\7\23\2\2\u0083\u0082\3\2\2\2\u0083\u0084\3\2\2\2\u0084")
        buf.write("\u0085\3\2\2\2\u0085\u0087\5 \21\2\u0086\u0083\3\2\2\2")
        buf.write("\u0086\u0087\3\2\2\2\u0087\u008e\3\2\2\2\u0088\u008e\7")
        buf.write("\31\2\2\u0089\u008b\7\23\2\2\u008a\u0089\3\2\2\2\u008a")
        buf.write("\u008b\3\2\2\2\u008b\u008c\3\2\2\2\u008c\u008e\7\30\2")
        buf.write("\2\u008dz\3\2\2\2\u008d}\3\2\2\2\u008d\u0088\3\2\2\2\u008d")
        buf.write("\u008a\3\2\2\2\u008e\35\3\2\2\2\u008f\u0093\7\25\2\2\u0090")
        buf.write("\u0093\7\26\2\2\u0091\u0093\5\22\n\2\u0092\u008f\3\2\2")
        buf.write("\2\u0092\u0090\3\2\2\2\u0092\u0091\3\2\2\2\u0093\37\3")
        buf.write("\2\2\2\u0094\u0096\5\24\13\2\u0095\u0094\3\2\2\2\u0095")
        buf.write("\u0096\3\2\2\2\u0096\u0097\3\2\2\2\u0097\u00a0\t\4\2\2")
        buf.write("\u0098\u009a\7\23\2\2\u0099\u0098\3\2\2\2\u009a\u009d")
        buf.write("\3\2\2\2\u009b\u0099\3\2\2\2\u009b\u009c\3\2\2\2\u009c")
        buf.write("\u009e\3\2\2\2\u009d\u009b\3\2\2\2\u009e\u00a0\7\3\2\2")
        buf.write("\u009f\u0095\3\2\2\2\u009f\u009b\3\2\2\2\u00a0!\3\2\2")
        buf.write("\2\u00a1\u00a2\t\5\2\2\u00a2#\3\2\2\2\u00a3\u00a5\7\23")
        buf.write("\2\2\u00a4\u00a3\3\2\2\2\u00a5\u00a8\3\2\2\2\u00a6\u00a4")
        buf.write("\3\2\2\2\u00a6\u00a7\3\2\2\2\u00a7\u00a9\3\2\2\2\u00a8")
        buf.write("\u00a6\3\2\2\2\u00a9\u00ad\7\16\2\2\u00aa\u00ac\7\23\2")
        buf.write("\2\u00ab\u00aa\3\2\2\2\u00ac\u00af\3\2\2\2\u00ad\u00ab")
        buf.write("\3\2\2\2\u00ad\u00ae\3\2\2\2\u00ae%\3\2\2\2\u00af\u00ad")
        buf.write("\3\2\2\2\30\'\64EHJX`fouz\177\u0083\u0086\u008a\u008d")
        buf.write("\u0092\u0095\u009b\u009f\u00a6\u00ad")
        return buf.getvalue()


class udunits2Parser ( Parser ):

    grammarFileName = "udunits2Parser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "'+'", "<INVALID>", "<INVALID>", 
                     "'.'", "'('", "')'", "':'" ]

    symbolicNames = [ "<INVALID>", "SIGNED_INT", "PLUS", "MULTIPLY", "DIVIDE", 
                      "PERIOD", "OPEN_PAREN", "CLOSE_PAREN", "SEMICOLON", 
                      "INT", "E_POWER", "FLOAT", "SHIFT_OP", "UNICODE_EXPONENT", 
                      "RAISE", "ID", "LATIN_SUBSET", "WS", "ERRORCHARACTER", 
                      "HOUR_MINUTE_SECOND", "HOUR_MINUTE", "DATE", "TIMESTAMP", 
                      "DT_T_CLOCK" ]

    RULE_unit_spec = 0
    RULE_shift_spec = 1
    RULE_product = 2
    RULE_power = 3
    RULE_basic_spec = 4
    RULE_integer = 5
    RULE_number = 6
    RULE_signed_int = 7
    RULE_any_int = 8
    RULE_sign = 9
    RULE_any_signed_number = 10
    RULE_any_unsigned_number = 11
    RULE_float_t = 12
    RULE_timestamp = 13
    RULE_signed_clock = 14
    RULE_signed_hour_minute = 15
    RULE_clock = 16
    RULE_shift = 17

    ruleNames =  [ "unit_spec", "shift_spec", "product", "power", "basic_spec", 
                   "integer", "number", "signed_int", "any_int", "sign", 
                   "any_signed_number", "any_unsigned_number", "float_t", 
                   "timestamp", "signed_clock", "signed_hour_minute", "clock", 
                   "shift" ]

    EOF = Token.EOF
    SIGNED_INT=1
    PLUS=2
    MULTIPLY=3
    DIVIDE=4
    PERIOD=5
    OPEN_PAREN=6
    CLOSE_PAREN=7
    SEMICOLON=8
    INT=9
    E_POWER=10
    FLOAT=11
    SHIFT_OP=12
    UNICODE_EXPONENT=13
    RAISE=14
    ID=15
    LATIN_SUBSET=16
    WS=17
    ERRORCHARACTER=18
    HOUR_MINUTE_SECOND=19
    HOUR_MINUTE=20
    DATE=21
    TIMESTAMP=22
    DT_T_CLOCK=23

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Unit_specContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(udunits2Parser.EOF, 0)

        def shift_spec(self):
            return self.getTypedRuleContext(udunits2Parser.Shift_specContext,0)


        def getRuleIndex(self):
            return udunits2Parser.RULE_unit_spec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit_spec" ):
                return visitor.visitUnit_spec(self)
            else:
                return visitor.visitChildren(self)




    def unit_spec(self):

        localctx = udunits2Parser.Unit_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_unit_spec)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 37
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << udunits2Parser.SIGNED_INT) | (1 << udunits2Parser.OPEN_PAREN) | (1 << udunits2Parser.INT) | (1 << udunits2Parser.FLOAT) | (1 << udunits2Parser.ID))) != 0):
                self.state = 36
                self.shift_spec()


            self.state = 39
            self.match(udunits2Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shift_specContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def product(self):
            return self.getTypedRuleContext(udunits2Parser.ProductContext,0)


        def shift(self):
            return self.getTypedRuleContext(udunits2Parser.ShiftContext,0)


        def number(self):
            return self.getTypedRuleContext(udunits2Parser.NumberContext,0)


        def timestamp(self):
            return self.getTypedRuleContext(udunits2Parser.TimestampContext,0)


        def getRuleIndex(self):
            return udunits2Parser.RULE_shift_spec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShift_spec" ):
                return visitor.visitShift_spec(self)
            else:
                return visitor.visitChildren(self)




    def shift_spec(self):

        localctx = udunits2Parser.Shift_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_shift_spec)
        try:
            self.state = 50
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 41
                self.product(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 42
                self.product(0)
                self.state = 43
                self.shift()
                self.state = 44
                self.number()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 46
                self.product(0)
                self.state = 47
                self.shift()
                self.state = 48
                self.timestamp()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProductContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def power(self):
            return self.getTypedRuleContext(udunits2Parser.PowerContext,0)


        def product(self):
            return self.getTypedRuleContext(udunits2Parser.ProductContext,0)


        def MULTIPLY(self):
            return self.getToken(udunits2Parser.MULTIPLY, 0)

        def DIVIDE(self):
            return self.getToken(udunits2Parser.DIVIDE, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(udunits2Parser.WS)
            else:
                return self.getToken(udunits2Parser.WS, i)

        def getRuleIndex(self):
            return udunits2Parser.RULE_product

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProduct" ):
                return visitor.visitProduct(self)
            else:
                return visitor.visitChildren(self)



    def product(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = udunits2Parser.ProductContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 4
        self.enterRecursionRule(localctx, 4, self.RULE_product, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53
            self.power()
            self._ctx.stop = self._input.LT(-1)
            self.state = 72
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 70
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
                    if la_ == 1:
                        localctx = udunits2Parser.ProductContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_product)
                        self.state = 55
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 56
                        self.power()
                        pass

                    elif la_ == 2:
                        localctx = udunits2Parser.ProductContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_product)
                        self.state = 57
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 58
                        self.match(udunits2Parser.MULTIPLY)
                        self.state = 59
                        self.power()
                        pass

                    elif la_ == 3:
                        localctx = udunits2Parser.ProductContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_product)
                        self.state = 60
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 61
                        self.match(udunits2Parser.DIVIDE)
                        self.state = 62
                        self.power()
                        pass

                    elif la_ == 4:
                        localctx = udunits2Parser.ProductContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_product)
                        self.state = 63
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 65 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while True:
                            self.state = 64
                            self.match(udunits2Parser.WS)
                            self.state = 67 
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if not (_la==udunits2Parser.WS):
                                break

                        self.state = 69
                        self.power()
                        pass

             
                self.state = 74
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PowerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basic_spec(self):
            return self.getTypedRuleContext(udunits2Parser.Basic_specContext,0)


        def any_int(self):
            return self.getTypedRuleContext(udunits2Parser.Any_intContext,0)


        def RAISE(self):
            return self.getToken(udunits2Parser.RAISE, 0)

        def UNICODE_EXPONENT(self):
            return self.getToken(udunits2Parser.UNICODE_EXPONENT, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_power

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPower" ):
                return visitor.visitPower(self)
            else:
                return visitor.visitChildren(self)




    def power(self):

        localctx = udunits2Parser.PowerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_power)
        try:
            self.state = 86
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 75
                self.basic_spec()
                self.state = 76
                self.any_int()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 78
                self.basic_spec()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 79
                self.basic_spec()
                self.state = 80
                self.match(udunits2Parser.RAISE)
                self.state = 81
                self.any_int()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 83
                self.basic_spec()
                self.state = 84
                self.match(udunits2Parser.UNICODE_EXPONENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Basic_specContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(udunits2Parser.ID, 0)

        def OPEN_PAREN(self):
            return self.getToken(udunits2Parser.OPEN_PAREN, 0)

        def shift_spec(self):
            return self.getTypedRuleContext(udunits2Parser.Shift_specContext,0)


        def CLOSE_PAREN(self):
            return self.getToken(udunits2Parser.CLOSE_PAREN, 0)

        def number(self):
            return self.getTypedRuleContext(udunits2Parser.NumberContext,0)


        def getRuleIndex(self):
            return udunits2Parser.RULE_basic_spec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasic_spec" ):
                return visitor.visitBasic_spec(self)
            else:
                return visitor.visitChildren(self)




    def basic_spec(self):

        localctx = udunits2Parser.Basic_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_basic_spec)
        try:
            self.state = 94
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [udunits2Parser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 88
                self.match(udunits2Parser.ID)
                pass
            elif token in [udunits2Parser.OPEN_PAREN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 89
                self.match(udunits2Parser.OPEN_PAREN)
                self.state = 90
                self.shift_spec()
                self.state = 91
                self.match(udunits2Parser.CLOSE_PAREN)
                pass
            elif token in [udunits2Parser.SIGNED_INT, udunits2Parser.INT, udunits2Parser.FLOAT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 93
                self.number()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(udunits2Parser.INT, 0)

        def SIGNED_INT(self):
            return self.getToken(udunits2Parser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_integer

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInteger" ):
                return visitor.visitInteger(self)
            else:
                return visitor.visitChildren(self)




    def integer(self):

        localctx = udunits2Parser.IntegerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_integer)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            _la = self._input.LA(1)
            if not(_la==udunits2Parser.SIGNED_INT or _la==udunits2Parser.INT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integer(self):
            return self.getTypedRuleContext(udunits2Parser.IntegerContext,0)


        def FLOAT(self):
            return self.getToken(udunits2Parser.FLOAT, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_number

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = udunits2Parser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_number)
        try:
            self.state = 100
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [udunits2Parser.SIGNED_INT, udunits2Parser.INT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 98
                self.integer()
                pass
            elif token in [udunits2Parser.FLOAT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 99
                self.match(udunits2Parser.FLOAT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_intContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(udunits2Parser.SIGNED_INT, 0)

        def INT(self):
            return self.getToken(udunits2Parser.INT, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_signed_int

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigned_int" ):
                return visitor.visitSigned_int(self)
            else:
                return visitor.visitChildren(self)




    def signed_int(self):

        localctx = udunits2Parser.Signed_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_signed_int)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            _la = self._input.LA(1)
            if not(_la==udunits2Parser.SIGNED_INT or _la==udunits2Parser.INT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Any_intContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(udunits2Parser.SIGNED_INT, 0)

        def INT(self):
            return self.getToken(udunits2Parser.INT, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_any_int

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAny_int" ):
                return visitor.visitAny_int(self)
            else:
                return visitor.visitChildren(self)




    def any_int(self):

        localctx = udunits2Parser.Any_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_any_int)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            _la = self._input.LA(1)
            if not(_la==udunits2Parser.SIGNED_INT or _la==udunits2Parser.INT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(udunits2Parser.PLUS, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_sign

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSign" ):
                return visitor.visitSign(self)
            else:
                return visitor.visitChildren(self)




    def sign(self):

        localctx = udunits2Parser.SignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_sign)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 106
            self.match(udunits2Parser.PLUS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Any_signed_numberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_unsigned_number(self):
            return self.getTypedRuleContext(udunits2Parser.Any_unsigned_numberContext,0)


        def sign(self):
            return self.getTypedRuleContext(udunits2Parser.SignContext,0)


        def getRuleIndex(self):
            return udunits2Parser.RULE_any_signed_number

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAny_signed_number" ):
                return visitor.visitAny_signed_number(self)
            else:
                return visitor.visitChildren(self)




    def any_signed_number(self):

        localctx = udunits2Parser.Any_signed_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_any_signed_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==udunits2Parser.PLUS:
                self.state = 108
                self.sign()


            self.state = 111
            self.any_unsigned_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Any_unsigned_numberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def float_t(self):
            return self.getTypedRuleContext(udunits2Parser.Float_tContext,0)


        def any_int(self):
            return self.getTypedRuleContext(udunits2Parser.Any_intContext,0)


        def getRuleIndex(self):
            return udunits2Parser.RULE_any_unsigned_number

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAny_unsigned_number" ):
                return visitor.visitAny_unsigned_number(self)
            else:
                return visitor.visitChildren(self)




    def any_unsigned_number(self):

        localctx = udunits2Parser.Any_unsigned_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_any_unsigned_number)
        try:
            self.state = 115
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [udunits2Parser.FLOAT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 113
                self.float_t()
                pass
            elif token in [udunits2Parser.SIGNED_INT, udunits2Parser.INT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 114
                self.any_int()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Float_tContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(udunits2Parser.FLOAT, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_float_t

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFloat_t" ):
                return visitor.visitFloat_t(self)
            else:
                return visitor.visitChildren(self)




    def float_t(self):

        localctx = udunits2Parser.Float_tContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_float_t)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.match(udunits2Parser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimestampContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE(self):
            return self.getToken(udunits2Parser.DATE, 0)

        def INT(self):
            return self.getToken(udunits2Parser.INT, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(udunits2Parser.WS)
            else:
                return self.getToken(udunits2Parser.WS, i)

        def signed_clock(self):
            return self.getTypedRuleContext(udunits2Parser.Signed_clockContext,0)


        def signed_hour_minute(self):
            return self.getTypedRuleContext(udunits2Parser.Signed_hour_minuteContext,0)


        def DT_T_CLOCK(self):
            return self.getToken(udunits2Parser.DT_T_CLOCK, 0)

        def TIMESTAMP(self):
            return self.getToken(udunits2Parser.TIMESTAMP, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_timestamp

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimestamp" ):
                return visitor.visitTimestamp(self)
            else:
                return visitor.visitChildren(self)




    def timestamp(self):

        localctx = udunits2Parser.TimestampContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_timestamp)
        self._la = 0 # Token type
        try:
            self.state = 139
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 120
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==udunits2Parser.WS:
                    self.state = 119
                    self.match(udunits2Parser.WS)


                self.state = 122
                _la = self._input.LA(1)
                if not(_la==udunits2Parser.INT or _la==udunits2Parser.DATE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 123
                _la = self._input.LA(1)
                if not(_la==udunits2Parser.INT or _la==udunits2Parser.DATE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 125
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==udunits2Parser.WS:
                    self.state = 124
                    self.match(udunits2Parser.WS)


                self.state = 127
                self.signed_clock()
                self.state = 132
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << udunits2Parser.SIGNED_INT) | (1 << udunits2Parser.PLUS) | (1 << udunits2Parser.INT) | (1 << udunits2Parser.WS) | (1 << udunits2Parser.HOUR_MINUTE))) != 0):
                    self.state = 129
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
                    if la_ == 1:
                        self.state = 128
                        self.match(udunits2Parser.WS)


                    self.state = 131
                    self.signed_hour_minute()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 134
                self.match(udunits2Parser.DT_T_CLOCK)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 136
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==udunits2Parser.WS:
                    self.state = 135
                    self.match(udunits2Parser.WS)


                self.state = 138
                self.match(udunits2Parser.TIMESTAMP)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_clockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HOUR_MINUTE_SECOND(self):
            return self.getToken(udunits2Parser.HOUR_MINUTE_SECOND, 0)

        def HOUR_MINUTE(self):
            return self.getToken(udunits2Parser.HOUR_MINUTE, 0)

        def any_int(self):
            return self.getTypedRuleContext(udunits2Parser.Any_intContext,0)


        def getRuleIndex(self):
            return udunits2Parser.RULE_signed_clock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigned_clock" ):
                return visitor.visitSigned_clock(self)
            else:
                return visitor.visitChildren(self)




    def signed_clock(self):

        localctx = udunits2Parser.Signed_clockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_signed_clock)
        try:
            self.state = 144
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [udunits2Parser.HOUR_MINUTE_SECOND]:
                self.enterOuterAlt(localctx, 1)
                self.state = 141
                self.match(udunits2Parser.HOUR_MINUTE_SECOND)
                pass
            elif token in [udunits2Parser.HOUR_MINUTE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 142
                self.match(udunits2Parser.HOUR_MINUTE)
                pass
            elif token in [udunits2Parser.SIGNED_INT, udunits2Parser.INT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 143
                self.any_int()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_hour_minuteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HOUR_MINUTE(self):
            return self.getToken(udunits2Parser.HOUR_MINUTE, 0)

        def INT(self):
            return self.getToken(udunits2Parser.INT, 0)

        def sign(self):
            return self.getTypedRuleContext(udunits2Parser.SignContext,0)


        def SIGNED_INT(self):
            return self.getToken(udunits2Parser.SIGNED_INT, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(udunits2Parser.WS)
            else:
                return self.getToken(udunits2Parser.WS, i)

        def getRuleIndex(self):
            return udunits2Parser.RULE_signed_hour_minute

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigned_hour_minute" ):
                return visitor.visitSigned_hour_minute(self)
            else:
                return visitor.visitChildren(self)




    def signed_hour_minute(self):

        localctx = udunits2Parser.Signed_hour_minuteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_signed_hour_minute)
        self._la = 0 # Token type
        try:
            self.state = 157
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [udunits2Parser.PLUS, udunits2Parser.INT, udunits2Parser.HOUR_MINUTE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 147
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==udunits2Parser.PLUS:
                    self.state = 146
                    self.sign()


                self.state = 149
                _la = self._input.LA(1)
                if not(_la==udunits2Parser.INT or _la==udunits2Parser.HOUR_MINUTE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [udunits2Parser.SIGNED_INT, udunits2Parser.WS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 153
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==udunits2Parser.WS:
                    self.state = 150
                    self.match(udunits2Parser.WS)
                    self.state = 155
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 156
                self.match(udunits2Parser.SIGNED_INT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HOUR_MINUTE(self):
            return self.getToken(udunits2Parser.HOUR_MINUTE, 0)

        def HOUR_MINUTE_SECOND(self):
            return self.getToken(udunits2Parser.HOUR_MINUTE_SECOND, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_clock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClock" ):
                return visitor.visitClock(self)
            else:
                return visitor.visitChildren(self)




    def clock(self):

        localctx = udunits2Parser.ClockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_clock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 159
            _la = self._input.LA(1)
            if not(_la==udunits2Parser.HOUR_MINUTE_SECOND or _la==udunits2Parser.HOUR_MINUTE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShiftContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHIFT_OP(self):
            return self.getToken(udunits2Parser.SHIFT_OP, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(udunits2Parser.WS)
            else:
                return self.getToken(udunits2Parser.WS, i)

        def getRuleIndex(self):
            return udunits2Parser.RULE_shift

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShift" ):
                return visitor.visitShift(self)
            else:
                return visitor.visitChildren(self)




    def shift(self):

        localctx = udunits2Parser.ShiftContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_shift)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==udunits2Parser.WS:
                self.state = 161
                self.match(udunits2Parser.WS)
                self.state = 166
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 167
            self.match(udunits2Parser.SHIFT_OP)
            self.state = 171
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,21,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 168
                    self.match(udunits2Parser.WS) 
                self.state = 173
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,21,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[2] = self.product_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def product_sempred(self, localctx:ProductContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 1)
         




